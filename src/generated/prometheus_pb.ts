// Copyright 2017 Prometheus Team
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file prometheus.proto (package prometheus, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message prometheus.MetricMetadata
 */
export class MetricMetadata extends Message<MetricMetadata> {
  /**
   * Represents the metric type, these match the set from Prometheus.
   * Refer to model/textparse/interface.go for details.
   *
   * @generated from field: prometheus.MetricMetadata.MetricType type = 1;
   */
  type = MetricMetadata_MetricType.UNKNOWN;

  /**
   * @generated from field: string metric_family_name = 2;
   */
  metricFamilyName = "";

  /**
   * @generated from field: string help = 4;
   */
  help = "";

  /**
   * @generated from field: string unit = 5;
   */
  unit = "";

  constructor(data?: PartialMessage<MetricMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.MetricMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(MetricMetadata_MetricType) },
    { no: 2, name: "metric_family_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "help", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricMetadata {
    return new MetricMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricMetadata {
    return new MetricMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricMetadata {
    return new MetricMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MetricMetadata | PlainMessage<MetricMetadata> | undefined, b: MetricMetadata | PlainMessage<MetricMetadata> | undefined): boolean {
    return proto3.util.equals(MetricMetadata, a, b);
  }
}

/**
 * @generated from enum prometheus.MetricMetadata.MetricType
 */
export enum MetricMetadata_MetricType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: COUNTER = 1;
   */
  COUNTER = 1,

  /**
   * @generated from enum value: GAUGE = 2;
   */
  GAUGE = 2,

  /**
   * @generated from enum value: HISTOGRAM = 3;
   */
  HISTOGRAM = 3,

  /**
   * @generated from enum value: GAUGEHISTOGRAM = 4;
   */
  GAUGEHISTOGRAM = 4,

  /**
   * @generated from enum value: SUMMARY = 5;
   */
  SUMMARY = 5,

  /**
   * @generated from enum value: INFO = 6;
   */
  INFO = 6,

  /**
   * @generated from enum value: STATESET = 7;
   */
  STATESET = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricMetadata_MetricType)
proto3.util.setEnumType(MetricMetadata_MetricType, "prometheus.MetricMetadata.MetricType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "COUNTER" },
  { no: 2, name: "GAUGE" },
  { no: 3, name: "HISTOGRAM" },
  { no: 4, name: "GAUGEHISTOGRAM" },
  { no: 5, name: "SUMMARY" },
  { no: 6, name: "INFO" },
  { no: 7, name: "STATESET" },
]);

/**
 * @generated from message prometheus.Sample
 */
export class Sample extends Message<Sample> {
  /**
   * @generated from field: double value = 1;
   */
  value = 0;

  /**
   * timestamp is in ms format, see model/timestamp/timestamp.go for
   * conversion from time.Time to Prometheus timestamp.
   *
   * @generated from field: int64 timestamp = 2;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Sample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.Sample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sample {
    return new Sample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJsonString(jsonString, options);
  }

  static equals(a: Sample | PlainMessage<Sample> | undefined, b: Sample | PlainMessage<Sample> | undefined): boolean {
    return proto3.util.equals(Sample, a, b);
  }
}

/**
 * @generated from message prometheus.Exemplar
 */
export class Exemplar extends Message<Exemplar> {
  /**
   * Optional, can be empty.
   *
   * @generated from field: repeated prometheus.Label labels = 1;
   */
  labels: Label[] = [];

  /**
   * @generated from field: double value = 2;
   */
  value = 0;

  /**
   * timestamp is in ms format, see model/timestamp/timestamp.go for
   * conversion from time.Time to Prometheus timestamp.
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Exemplar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.Exemplar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 2, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Exemplar {
    return new Exemplar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJsonString(jsonString, options);
  }

  static equals(a: Exemplar | PlainMessage<Exemplar> | undefined, b: Exemplar | PlainMessage<Exemplar> | undefined): boolean {
    return proto3.util.equals(Exemplar, a, b);
  }
}

/**
 * A native histogram, also known as a sparse histogram.
 * Original design doc:
 * https://docs.google.com/document/d/1cLNv3aufPZb3fNfaJgdaRBZsInZKKIHo9E6HinJVbpM/edit
 * The appendix of this design doc also explains the concept of float
 * histograms. This Histogram message can represent both, the usual
 * integer histogram as well as a float histogram.
 *
 * @generated from message prometheus.Histogram
 */
export class Histogram extends Message<Histogram> {
  /**
   * Count of observations in the histogram.
   *
   * @generated from oneof prometheus.Histogram.count
   */
  count: {
    /**
     * @generated from field: uint64 count_int = 1;
     */
    value: bigint;
    case: "countInt";
  } | {
    /**
     * @generated from field: double count_float = 2;
     */
    value: number;
    case: "countFloat";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Sum of observations in the histogram.
   *
   * @generated from field: double sum = 3;
   */
  sum = 0;

  /**
   * The schema defines the bucket schema. Currently, valid numbers
   * are -4 <= n <= 8. They are all for base-2 bucket schemas, where 1
   * is a bucket boundary in each case, and then each power of two is
   * divided into 2^n logarithmic buckets. Or in other words, each
   * bucket boundary is the previous boundary times 2^(2^-n). In the
   * future, more bucket schemas may be added using numbers < -4 or >
   * 8.
   *
   * @generated from field: sint32 schema = 4;
   */
  schema = 0;

  /**
   * Breadth of the zero bucket.
   *
   * @generated from field: double zero_threshold = 5;
   */
  zeroThreshold = 0;

  /**
   * Count in zero bucket.
   *
   * @generated from oneof prometheus.Histogram.zero_count
   */
  zeroCount: {
    /**
     * @generated from field: uint64 zero_count_int = 6;
     */
    value: bigint;
    case: "zeroCountInt";
  } | {
    /**
     * @generated from field: double zero_count_float = 7;
     */
    value: number;
    case: "zeroCountFloat";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Negative Buckets.
   *
   * @generated from field: repeated prometheus.BucketSpan negative_spans = 8;
   */
  negativeSpans: BucketSpan[] = [];

  /**
   * Use either "negative_deltas" or "negative_counts", the former for
   * regular histograms with integer counts, the latter for float
   * histograms.
   *
   * Count delta of each bucket compared to previous one (or to zero for 1st bucket).
   *
   * @generated from field: repeated sint64 negative_deltas = 9;
   */
  negativeDeltas: bigint[] = [];

  /**
   * Absolute count of each bucket.
   *
   * @generated from field: repeated double negative_counts = 10;
   */
  negativeCounts: number[] = [];

  /**
   * Positive Buckets.
   *
   * @generated from field: repeated prometheus.BucketSpan positive_spans = 11;
   */
  positiveSpans: BucketSpan[] = [];

  /**
   * Use either "positive_deltas" or "positive_counts", the former for
   * regular histograms with integer counts, the latter for float
   * histograms.
   *
   * Count delta of each bucket compared to previous one (or to zero for 1st bucket).
   *
   * @generated from field: repeated sint64 positive_deltas = 12;
   */
  positiveDeltas: bigint[] = [];

  /**
   * Absolute count of each bucket.
   *
   * @generated from field: repeated double positive_counts = 13;
   */
  positiveCounts: number[] = [];

  /**
   * @generated from field: prometheus.Histogram.ResetHint reset_hint = 14;
   */
  resetHint = Histogram_ResetHint.UNKNOWN;

  /**
   * timestamp is in ms format, see model/timestamp/timestamp.go for
   * conversion from time.Time to Prometheus timestamp.
   *
   * @generated from field: int64 timestamp = 15;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<Histogram>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.Histogram";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count_int", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "count" },
    { no: 2, name: "count_float", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "count" },
    { no: 3, name: "sum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "schema", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
    { no: 5, name: "zero_threshold", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "zero_count_int", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "zero_count" },
    { no: 7, name: "zero_count_float", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "zero_count" },
    { no: 8, name: "negative_spans", kind: "message", T: BucketSpan, repeated: true },
    { no: 9, name: "negative_deltas", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
    { no: 10, name: "negative_counts", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 11, name: "positive_spans", kind: "message", T: BucketSpan, repeated: true },
    { no: 12, name: "positive_deltas", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
    { no: 13, name: "positive_counts", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 14, name: "reset_hint", kind: "enum", T: proto3.getEnumType(Histogram_ResetHint) },
    { no: 15, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Histogram {
    return new Histogram().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Histogram {
    return new Histogram().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Histogram {
    return new Histogram().fromJsonString(jsonString, options);
  }

  static equals(a: Histogram | PlainMessage<Histogram> | undefined, b: Histogram | PlainMessage<Histogram> | undefined): boolean {
    return proto3.util.equals(Histogram, a, b);
  }
}

/**
 * @generated from enum prometheus.Histogram.ResetHint
 */
export enum Histogram_ResetHint {
  /**
   * Need to test for a counter reset explicitly.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * This is the 1st histogram after a counter reset.
   *
   * @generated from enum value: YES = 1;
   */
  YES = 1,

  /**
   * There was no counter reset between this and the previous Histogram.
   *
   * @generated from enum value: NO = 2;
   */
  NO = 2,

  /**
   * This is a gauge histogram where counter resets don't happen.
   *
   * @generated from enum value: GAUGE = 3;
   */
  GAUGE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Histogram_ResetHint)
proto3.util.setEnumType(Histogram_ResetHint, "prometheus.Histogram.ResetHint", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "YES" },
  { no: 2, name: "NO" },
  { no: 3, name: "GAUGE" },
]);

/**
 * A BucketSpan defines a number of consecutive buckets with their
 * offset. Logically, it would be more straightforward to include the
 * bucket counts in the Span. However, the protobuf representation is
 * more compact in the way the data is structured here (with all the
 * buckets in a single array separate from the Spans).
 *
 * @generated from message prometheus.BucketSpan
 */
export class BucketSpan extends Message<BucketSpan> {
  /**
   * Gap to previous span, or starting point for 1st span (which can be negative).
   *
   * @generated from field: sint32 offset = 1;
   */
  offset = 0;

  /**
   * Length of consecutive buckets.
   *
   * @generated from field: uint32 length = 2;
   */
  length = 0;

  constructor(data?: PartialMessage<BucketSpan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.BucketSpan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "offset", kind: "scalar", T: 17 /* ScalarType.SINT32 */ },
    { no: 2, name: "length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BucketSpan {
    return new BucketSpan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BucketSpan {
    return new BucketSpan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BucketSpan {
    return new BucketSpan().fromJsonString(jsonString, options);
  }

  static equals(a: BucketSpan | PlainMessage<BucketSpan> | undefined, b: BucketSpan | PlainMessage<BucketSpan> | undefined): boolean {
    return proto3.util.equals(BucketSpan, a, b);
  }
}

/**
 * TimeSeries represents samples and labels for a single time series.
 *
 * @generated from message prometheus.TimeSeries
 */
export class TimeSeries extends Message<TimeSeries> {
  /**
   * For a timeseries to be valid, and for the samples and exemplars
   * to be ingested by the remote system properly, the labels field is required.
   *
   * @generated from field: repeated prometheus.Label labels = 1;
   */
  labels: Label[] = [];

  /**
   * @generated from field: repeated prometheus.Sample samples = 2;
   */
  samples: Sample[] = [];

  /**
   * @generated from field: repeated prometheus.Exemplar exemplars = 3;
   */
  exemplars: Exemplar[] = [];

  /**
   * @generated from field: repeated prometheus.Histogram histograms = 4;
   */
  histograms: Histogram[] = [];

  constructor(data?: PartialMessage<TimeSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.TimeSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 2, name: "samples", kind: "message", T: Sample, repeated: true },
    { no: 3, name: "exemplars", kind: "message", T: Exemplar, repeated: true },
    { no: 4, name: "histograms", kind: "message", T: Histogram, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeries {
    return new TimeSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeries | PlainMessage<TimeSeries> | undefined, b: TimeSeries | PlainMessage<TimeSeries> | undefined): boolean {
    return proto3.util.equals(TimeSeries, a, b);
  }
}

/**
 * @generated from message prometheus.Label
 */
export class Label extends Message<Label> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<Label>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.Label";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Label {
    return new Label().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Label {
    return new Label().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Label {
    return new Label().fromJsonString(jsonString, options);
  }

  static equals(a: Label | PlainMessage<Label> | undefined, b: Label | PlainMessage<Label> | undefined): boolean {
    return proto3.util.equals(Label, a, b);
  }
}

/**
 * @generated from message prometheus.Labels
 */
export class Labels extends Message<Labels> {
  /**
   * @generated from field: repeated prometheus.Label labels = 1;
   */
  labels: Label[] = [];

  constructor(data?: PartialMessage<Labels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.Labels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "message", T: Label, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Labels {
    return new Labels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Labels {
    return new Labels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Labels {
    return new Labels().fromJsonString(jsonString, options);
  }

  static equals(a: Labels | PlainMessage<Labels> | undefined, b: Labels | PlainMessage<Labels> | undefined): boolean {
    return proto3.util.equals(Labels, a, b);
  }
}

/**
 * Matcher specifies a rule, which can match or set of labels or not.
 *
 * @generated from message prometheus.LabelMatcher
 */
export class LabelMatcher extends Message<LabelMatcher> {
  /**
   * @generated from field: prometheus.LabelMatcher.Type type = 1;
   */
  type = LabelMatcher_Type.EQ;

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  constructor(data?: PartialMessage<LabelMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.LabelMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(LabelMatcher_Type) },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelMatcher {
    return new LabelMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelMatcher {
    return new LabelMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelMatcher {
    return new LabelMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: LabelMatcher | PlainMessage<LabelMatcher> | undefined, b: LabelMatcher | PlainMessage<LabelMatcher> | undefined): boolean {
    return proto3.util.equals(LabelMatcher, a, b);
  }
}

/**
 * @generated from enum prometheus.LabelMatcher.Type
 */
export enum LabelMatcher_Type {
  /**
   * @generated from enum value: EQ = 0;
   */
  EQ = 0,

  /**
   * @generated from enum value: NEQ = 1;
   */
  NEQ = 1,

  /**
   * @generated from enum value: RE = 2;
   */
  RE = 2,

  /**
   * @generated from enum value: NRE = 3;
   */
  NRE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LabelMatcher_Type)
proto3.util.setEnumType(LabelMatcher_Type, "prometheus.LabelMatcher.Type", [
  { no: 0, name: "EQ" },
  { no: 1, name: "NEQ" },
  { no: 2, name: "RE" },
  { no: 3, name: "NRE" },
]);

/**
 * @generated from message prometheus.ReadHints
 */
export class ReadHints extends Message<ReadHints> {
  /**
   * Query step size in milliseconds.
   *
   * @generated from field: int64 step_ms = 1;
   */
  stepMs = protoInt64.zero;

  /**
   * String representation of surrounding function or aggregation.
   *
   * @generated from field: string func = 2;
   */
  func = "";

  /**
   * Start time in milliseconds.
   *
   * @generated from field: int64 start_ms = 3;
   */
  startMs = protoInt64.zero;

  /**
   * End time in milliseconds.
   *
   * @generated from field: int64 end_ms = 4;
   */
  endMs = protoInt64.zero;

  /**
   * List of label names used in aggregation.
   *
   * @generated from field: repeated string grouping = 5;
   */
  grouping: string[] = [];

  /**
   * Indicate whether it is without or by.
   *
   * @generated from field: bool by = 6;
   */
  by = false;

  /**
   * Range vector selector range in milliseconds.
   *
   * @generated from field: int64 range_ms = 7;
   */
  rangeMs = protoInt64.zero;

  constructor(data?: PartialMessage<ReadHints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.ReadHints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "step_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "func", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "start_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "end_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "grouping", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "by", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "range_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadHints {
    return new ReadHints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadHints {
    return new ReadHints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadHints {
    return new ReadHints().fromJsonString(jsonString, options);
  }

  static equals(a: ReadHints | PlainMessage<ReadHints> | undefined, b: ReadHints | PlainMessage<ReadHints> | undefined): boolean {
    return proto3.util.equals(ReadHints, a, b);
  }
}

/**
 * Chunk represents a TSDB chunk.
 * Time range [min, max] is inclusive.
 *
 * @generated from message prometheus.Chunk
 */
export class Chunk extends Message<Chunk> {
  /**
   * @generated from field: int64 min_time_ms = 1;
   */
  minTimeMs = protoInt64.zero;

  /**
   * @generated from field: int64 max_time_ms = 2;
   */
  maxTimeMs = protoInt64.zero;

  /**
   * @generated from field: prometheus.Chunk.Encoding type = 3;
   */
  type = Chunk_Encoding.UNKNOWN;

  /**
   * @generated from field: bytes data = 4;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<Chunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.Chunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min_time_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "max_time_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(Chunk_Encoding) },
    { no: 4, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Chunk {
    return new Chunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Chunk {
    return new Chunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Chunk {
    return new Chunk().fromJsonString(jsonString, options);
  }

  static equals(a: Chunk | PlainMessage<Chunk> | undefined, b: Chunk | PlainMessage<Chunk> | undefined): boolean {
    return proto3.util.equals(Chunk, a, b);
  }
}

/**
 * We require this to match chunkenc.Encoding.
 *
 * @generated from enum prometheus.Chunk.Encoding
 */
export enum Chunk_Encoding {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: XOR = 1;
   */
  XOR = 1,

  /**
   * @generated from enum value: HISTOGRAM = 2;
   */
  HISTOGRAM = 2,

  /**
   * @generated from enum value: FLOAT_HISTOGRAM = 3;
   */
  FLOAT_HISTOGRAM = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Chunk_Encoding)
proto3.util.setEnumType(Chunk_Encoding, "prometheus.Chunk.Encoding", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "XOR" },
  { no: 2, name: "HISTOGRAM" },
  { no: 3, name: "FLOAT_HISTOGRAM" },
]);

/**
 * ChunkedSeries represents single, encoded time series.
 *
 * @generated from message prometheus.ChunkedSeries
 */
export class ChunkedSeries extends Message<ChunkedSeries> {
  /**
   * Labels should be sorted.
   *
   * @generated from field: repeated prometheus.Label labels = 1;
   */
  labels: Label[] = [];

  /**
   * Chunks will be in start time order and may overlap.
   *
   * @generated from field: repeated prometheus.Chunk chunks = 2;
   */
  chunks: Chunk[] = [];

  constructor(data?: PartialMessage<ChunkedSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "prometheus.ChunkedSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 2, name: "chunks", kind: "message", T: Chunk, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChunkedSeries {
    return new ChunkedSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChunkedSeries {
    return new ChunkedSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChunkedSeries {
    return new ChunkedSeries().fromJsonString(jsonString, options);
  }

  static equals(a: ChunkedSeries | PlainMessage<ChunkedSeries> | undefined, b: ChunkedSeries | PlainMessage<ChunkedSeries> | undefined): boolean {
    return proto3.util.equals(ChunkedSeries, a, b);
  }
}

